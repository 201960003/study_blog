---
layout: post
title:  ⌜HTML⌟ 스티커 추가 및 그림 그리기 기능
date:   2025-01-26 +0900
categories: HTML
---
<style>
    #drawing-canvas {
        border: 1px solid black;
        background-color: white;
        display: block;
        /* margin: 20px auto; */
    }

     /*  color-picker  */
    .color-picker {
        display: flex;
        margin-bottom: 10px;
    }

    .color-button {
        position: relative;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        margin: 5px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .color-button span {
        display: none;
        color: white;
        font-size: 20px;
    }

    .color-button.selected span {
        display: block;
    }

    .black { background-color: black; color: white; }
    .red { background-color: red; }
    .orange { background-color: orange; }
    .yellow { background-color: yellow; }
    .green { background-color: green; }
    .blue { background-color: blue; }
    .indigo { background-color: indigo; }
    .violet { background-color: violet; }


    .sticker-container {
        width: 50%;
        height: 30%
    }

    .sticker {
        width: 100px;
        height: 100px;
    }
</style>
<div class="canvas-container">
    <canvas id="background-canvas" width="300" height="300"></canvas>
    <canvas id="drawing-canvas" width="300" height="300"></canvas>
</div>

<div class="controls">
    <label for="line-width">선 두께: </label>
    <input type="range" id="line-width" min="1" max="10" value="1">
    <button id="eraser">지우개 켜기</button>
    <button id="allclear">모두 지우기</button>
</div>
        
<div class="color-picker">
    <div class="color-button black selected" data-color="black"><span>&#10003;</span></div>
    <div class="color-button red" data-color="red"><span>&#10003;</span></div>
    <div class="color-button orange" data-color="orange"><span>&#10003;</span></div>
    <div class="color-button yellow" data-color="yellow"><span>&#10003;</span></div>
    <div class="color-button green" data-color="green"><span>&#10003;</span></div>
    <div class="color-button blue" data-color="blue"><span>&#10003;</span></div>
    <div class="color-button indigo" data-color="indigo"><span>&#10003;</span></div>
    <div class="color-button violet" data-color="violet"><span>&#10003;</span></div>
</div>

<div class=sticker-container>
    <img class="sticker" src="https://github.com/201960003/study_blog/blob/main/img/post25/four_leaf_clover.png?raw=true"></img>
    <img class="sticker" src="https://github.com/201960003/study_blog/blob/main/img/post25/three_leaf_clover.png?raw=true"></img>
</div>
        
<button id="save" onclick="saveCanvas()">저장</button>

<script>
    // canvas part
    var drawingCanvas = document.getElementById("drawing-canvas"); // 선 그리기 canvas
    var stickerBoard = document.getElementById("background-canvas"); // 스티커 그리기 canvas
    var drawingContext = drawingCanvas.getContext("2d"); // drawingCanvas의 context
    var backgroundContext = stickerBoard.getContext("2d"); // backgroundCanvas의 context

    function saveCanvas() {
        var compositeCanvas = document.createElement('canvas'); // 그림 + 선 캠퍼스 합치기 위한 canvas 생성
        compositeCanvas.width = backgroundCanvas.width;
        compositeCanvas.height = backgroundCanvas.height;
        var compositeContext = compositeCanvas.getContext('2d'); //  compositeCanvas의 context 생성

        // 배경 캔버스와 드로잉 캔버스를 합침
        compositeContext.drawImage(backgroundCanvas, 0, 0);
        compositeContext.drawImage(drawingCanvas, 0, 0);

        // 합친 캔버스를 이미지로 변환하여 다운로드
        var dataURL = compositeCanvas.toDataURL('image/png');
        var link = document.createElement('a');
        link.href = dataURL;
        link.download = `${getCurrentDateTimeString()}.png`;
        link.click();
    }

    function getCurrentDateTimeString() {
        var today = new Date();
        var year = today.getFullYear();
        var month = String(today.getMonth() + 1).padStart(2, '0');
        var day = String(today.getDate()).padStart(2, '0');
        var hours = String(today.getHours()).padStart(2, '0');
        var minutes = String(today.getMinutes()).padStart(2, '0');
        var seconds = String(today.getSeconds()).padStart(2, '0');

        // Return formatted date and time string
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    }

    // line-controller part
    var lastX = 0; // 마지막 마우스 위치 x 값
    var lastY = 0; // 마지막 마우스 위치 y 값
    var isDrawing = false; // 그리기 상태, false : 안그리기
    var strokeStyle = 'black';  // 기본 선 색상
    var lineWidth = 1; // 기본 선 두께
    var lineCap = "round";  // 기본 선 모양
    var isErasing = false;  // 지우개 모드 여부


    function handleMouseDown(event) {
        // 마우스 클릭했을 때 실행되는 함수
        isDrawing = true;
        [lastX, lastY] = [event.offsetX, event.offsetY];
        // 현재 마우스 위치인 [event.offsetX, event.offsetY] 를 각각 lastX, lastY 에 저장
    };


    function handleMouseMove(event) {
        // 마우스가 canvas 태그내에서 움직였을 때 실행되는 함수
        if (!isDrawing) return;  // isDrawing이 false일 때는 return으로 함수를 종료
        // 마우스가 움직일 때 isDrawing이 true이면 현재 위치를 가져옴
        const currentX = event.offsetX;
        const currentY = event.offsetY;

        drawingContext.lineWidth = lineWidth; // 지정한 선 두께
        drawingContext.strokeStyle = strokeStyle; // 지정한 선 색상
        drawingContext.lineCap = lineCap; // 지정한 선 모양

        drawingContext.beginPath(); // context의 새로운 경로를 시작
        drawingContext.moveTo(lastX, lastY); // 마지막 마우스 위치
        drawingContext.lineTo(currentX, currentY); // moveTo로 지정한 이전 마우스 위치에서 현재 마우스 위치까지 선 그리기


        if (isErasing) {
            drawingContext.globalCompositeOperation = 'destination-out';
            drawingContext.stroke();
            drawingContext.globalCompositeOperation = 'source-over';
        } else {
            drawingContext.stroke();
        }
                
        // drawingContext.closePath(); // context의 경로를 종료

        [lastX, lastY] = [currentX, currentY]; // 현재 위치를 저장
    };

    function handleMouseUp() {
        // 마우스 클릭 해제했을 때 실행되는 함수
        isDrawing = false;
    };

    function handleMouseLeave() {
        // 마우스가 canvas 태그를 벗어났을 때 실행되는 함수
        isDrawing = false;
    };

    // 선 두께 슬라이더 이벤트 리스너
    document.getElementById('line-width').addEventListener('input', function() {
        lineWidth = this.value;
    });

    // 지우개 버튼 클릭 이벤트 리스너
    document.getElementById('eraser').addEventListener('click', function() {
        isErasing = !isErasing;  // 지우개 모드를 토글
        if (isErasing) {
            this.textContent = '지우개 끄기';
            // document.querySelectorAll('.color-button').forEach(btn => btn.classList.remove('selected'));  // 모든 색상 버튼 선택 해제
        } else {
            this.textContent = '지우개 켜기';
        }
    });

    document.querySelectorAll('.color-button').forEach(button => {
        button.addEventListener('click', function() {
            document.querySelectorAll('.color-button').forEach(btn => btn.classList.remove('selected')); // 기존에 체크되었던 색상은 해제
            this.classList.add('selected'); // 선택한건 체크표시 나오게
            strokeStyle = this.getAttribute('data-color'); // data-color 속성값으로 지정한 섹상변경
            isErasing = false;  // 지우개 모드를 해제
        });
    });

    // 마우스 이벤트
    drawingCanvas.addEventListener('mousedown', handleMouseDown);
    drawingCanvas.addEventListener('mousemove', handleMouseMove);
    drawingCanvas.addEventListener('mouseup', handleMouseUp);
    drawingCanvas.addEventListener('mouseleave', handleMouseLeave);

    // 터치 이벤트 리스너 추가
    drawingCanvas.addEventListener('touchstart', ()=>{
        handleMouseDown
        console.log("ddjdjdjdj")
    });
    drawingCanvas.addEventListener('touchmove', handleMouseMove);
    drawingCanvas.addEventListener('touchend', handleMouseUp);
    drawingCanvas.addEventListener('touchcancel',handleMouseLeave);

    document.getElementById('allclear').addEventListener('click', function() {
        drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    }); // 모두 지우기

    // 스티커 컨테이너
    const stickers = document.querySelectorAll('.sticker img');
    stickers.forEach(sticker => {
        sticker.addEventListener('click', onClick);
        sticker.addEventListener('touchstart', onClick, { passive: false });
    });

    stickerBoard.addEventListener('dragover', onDragOver);
    stickerBoard.addEventListener('drop', onDrop);
    stickerBoard.addEventListener('touchstart', onTouchStart, { passive: false });
    stickerBoard.addEventListener('touchmove', onTouchMove, { passive: false });
    stickerBoard.addEventListener('touchend', onTouchEnd);

    function onClick(e) {
        e.preventDefault();
        const rect = stickerBoard.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;

            draggedSticker = e.target;

            placeSticker(centerX, centerY);
        }

        function onDragOver(e) {
            e.preventDefault();
        }

        function onDrop(e) {
            e.preventDefault();
            const rect = stickerBoard.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            placeSticker(x, y);
        }

        function onTouchMove(e) {
            if (draggedSticker && stickerBoard.contains(draggedSticker)) {
                if (e.touches.length === 2) {
                    e.preventDefault();  // 기본 터치 동작 방지 (줌 등)

                    const currentDistance = getDistance(e.touches[0], e.touches[1]);
                    const currentAngle = getAngle(e.touches[0], e.touches[1]);
                    const scale = currentDistance / initialDistance;
                    draggedSticker.style.transform = `scale(${scale}) rotate(${currentAngle}deg)`;


                } else if (e.touches.length === 1) {
                    // 드래그 처리
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = stickerBoard.getBoundingClientRect();
                    const x = touch.clientX - rect.left - 50;
                    const y = touch.clientY - rect.top - 50;

                    if (y > rect.height * 0.6) {
                        showTrashBin(true);
                    } else {
                        showTrashBin(false);
                    }

                    updateStickerPosition(x, y);

                }

            }
        }

        function getDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getAngle(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.atan2(dy, dx) * (180 / Math.PI);
        }

        function updateStickerPosition(x, y) {
            if (!draggedSticker) return;

            const stickerBoardRect = stickerBoard.getBoundingClientRect();
            const stickerWidth = draggedSticker.offsetWidth;
            const stickerHeight = draggedSticker.offsetHeight;

            let newX = Math.max(0, Math.min(x, stickerBoardRect.width));
            let newY = Math.max(0, Math.min(y, stickerBoardRect.height));

            draggedSticker.style.left = `${newX}px`;
            draggedSticker.style.top = `${newY}px`;
        }



        function onTouchEnd(e) {
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = stickerBoard.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            if (isOverTrashBin(x, y)) {
                deleteSticker(draggedSticker);
            }
            showTrashBin(false);
            draggedSticker = null;
        }



        function placeSticker(x, y) {
            if (!draggedSticker) return;

            const stickerWidth = draggedSticker.offsetWidth;
            const stickerHeight = draggedSticker.offsetHeight;
            const newX = x - stickerWidth / 2;
            const newY = y - stickerHeight / 2;

            const rotation = draggedSticker.dataset.rotation || 0;

            if (draggedSticker.parentElement === stickerBoard) {
                // 이미 스티커보드에 있는 경우 위치만 업데이트
                draggedSticker.style.left = newX + 'px';
                draggedSticker.style.top = newY + 'px';
                draggedSticker.style.transform = `rotate(${rotation}deg)`;
            } else {
                // 스티커보드에 새로 추가할 경우
                const newSticker = document.createElement('img');
                newSticker.src = draggedSticker.src;
                newSticker.style.position = 'absolute';
                newSticker.style.left = newX + 'px';
                newSticker.style.top = newY + 'px';
                newSticker.style.width = "100px";
                newSticker.style.height = "100px";
                newSticker.draggable = true;

                newSticker.addEventListener('dragstart', onDragStart);
                newSticker.addEventListener('touchstart', onTouchStart, { passive: false });

                stickerBoard.appendChild(newSticker);
            }
            draggedSticker = null;
        }

        function onDragStart(e) {
            draggedSticker = e.target;
            e.dataTransfer.setData('text/plain', null);
        }

        function onTouchStart(e) {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const target = touch.target;

                if (target.tagName.toLowerCase() === 'img' && stickerBoard.contains(target)) {
                    draggedSticker = target;

                    const rect = draggedSticker.getBoundingClientRect();
                    offsetX = touch.clientX - rect.left;
                    offsetY = touch.clientY - rect.top;
                }
            } else if (e.touches.length === 2) {
                // 두 손가락 터치 - 크기 및 각도 조절 시작
                initialDistance = getDistance(e.touches[0], e.touches[1]);
                initialAngle = getAngle(e.touches[0], e.touches[1]);
            }
        }


        function showTrashBin(show) {
            if (show) {
                trashBin.classList.add('visible');
            } else {
                trashBin.classList.remove('visible');
            }
        }


        function checkForTrashBinHover(x, y) {
            const rect = stickerBoard.getBoundingClientRect();
            const stickerX = x - rect.left;
            const stickerY = y - rect.top;

            if (isOverTrashBin(stickerX, stickerY)) {
                trashBin.style.backgroundColor = 'red';
            } else {
                trashBin.style.backgroundColor = 'gray';
            }
        }

        function isOverTrashBin(x, y) {
            const trashRect = trashBin.getBoundingClientRect();
            const stickerBoardRect = stickerBoard.getBoundingClientRect();

            // Trash bin의 좌표를 스티커 보드 좌표로 변환
            const trashBinLeft = trashRect.left - stickerBoardRect.left;
            const trashBinTop = trashRect.top - stickerBoardRect.top;

            return (
                x >= trashBinLeft &&
                x <= trashBinLeft + trashRect.width &&
                y >= trashBinTop &&
                y <= trashBinTop + trashRect.height
            );
        }



        function deleteSticker(sticker) {
            if (sticker && sticker.parentNode) {
                sticker.parentNode.removeChild(sticker);
            }
        }


</script>


<!-- <br><br> -->

### 🧐 오늘의 소감은?
최종적으로 이미지를 프로젝트 폴더 안에 public 폴더 안에 직접 사진을 넣어서 작업을 한 부분이 아쉽긴 하지만 그래도 이 코드 이후에 확장성이 좋다고 생각을 하기 떄문에 살짝 뿌듯... 함이 있긴 합니다. 최근 플러터로 작업을 하다가 이렇게 웹으르 조금 다루니까 살짝 재미있어진 것 같아요. 요즘 아직 간단한것만 하는데 그래도 점점 어려운 것도 해내는 아기 개발자가 되고 싶어요!! 열심히 빠샤빠샤

<br>