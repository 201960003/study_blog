<style>
  .main-container {
    position: relative;
    width: 100%;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 24px;
    padding: 30px 20px;
    background: linear-gradient(145deg, #1f1c2c, #000000);
    border-radius: 20px;
    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
    font-family: 'Inter', -apple-system, sans-serif;
  }

  .canvas-container {
    position: relative;
    width: 100%;
    max-width: 800px;
    height: 60vh;
    min-height: 400px;
    background: radial-gradient(circle at 50% 50%, rgba(40, 10, 30, 0.5), rgba(0, 0, 0, 0.8));
    border-radius: 16px;
    overflow: hidden;
    box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.9);
    border: 1px solid rgba(255, 255, 255, 0.05);
  }

  .canvas-container::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 250px;
    height: 250px;
    background: radial-gradient(circle at 50% 50%, rgba(255, 20, 147, 0.2), transparent 70%);
    border-radius: 50%;
    z-index: 0;
    animation: pulse 3s ease-in-out infinite;
  }

  .canvas-container::after {
    content: '♥';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 150px;
    color: rgba(255, 20, 147, 0.15);
    text-shadow:
      0 0 20px rgba(255, 20, 147, 0.4),
      0 0 40px rgba(255, 20, 147, 0.2);
    z-index: 0;
    animation: glow 2s ease-in-out infinite alternate;
    pointer-events: none;
  }

  @keyframes pulse {

    0%,
    100% {
      opacity: 0.3;
      transform: translate(-50%, -50%) scale(1);
    }

    50% {
      opacity: 0.5;
      transform: translate(-50%, -50%) scale(1.1);
    }
  }

  @keyframes glow {
    0% {
      opacity: 0.2;
      text-shadow: 0 0 20px rgba(255, 20, 147, 0.4);
    }

    100% {
      opacity: 0.5;
      text-shadow: 0 0 40px rgba(255, 20, 147, 0.6);
    }
  }

  canvas {
    display: block;
    width: 100%;
    height: 100%;
    position: relative;
    z-index: 1;
    cursor: grab;
  }

  canvas:active {
    cursor: grabbing;
  }

  .controls-panel {
    width: 100%;
    max-width: 500px;
    display: flex;
    flex-direction: column;
    gap: 16px;
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    padding: 24px;
    border-radius: 16px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  }

  .controls-title {
    color: #ffb6c1;
    font-size: 1.1rem;
    font-weight: 600;
    text-align: center;
    margin-top: 0;
    margin-bottom: 8px;
    letter-spacing: 1px;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
  }

  .slider-group {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 15px;
    width: 100%;
  }

  .slider-label {
    min-width: 45px;
    font-size: 0.95rem;
    font-weight: 600;
    color: #fff;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
  }

  .slider {
    -webkit-appearance: none;
    appearance: none;
    flex-grow: 1;
    height: 6px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    outline: none;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
    transition: background 0.3s;
  }

  .slider:hover {
    background: rgba(255, 255, 255, 0.2);
  }

  .slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: linear-gradient(135deg, #ff6b9d, #ff3366);
    cursor: pointer;
    box-shadow: 0 0 10px rgba(255, 51, 102, 0.5), 0 2px 5px rgba(0, 0, 0, 0.3);
    border: 2px solid white;
    transition: transform 0.1s;
  }

  .slider::-webkit-slider-thumb:hover {
    transform: scale(1.15);
    box-shadow: 0 0 15px rgba(255, 51, 102, 0.8), 0 2px 5px rgba(0, 0, 0, 0.3);
  }

  .slider::-moz-range-thumb {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: linear-gradient(135deg, #ff6b9d, #ff3366);
    cursor: pointer;
    box-shadow: 0 0 10px rgba(255, 51, 102, 0.5), 0 2px 5px rgba(0, 0, 0, 0.3);
    border: 2px solid white;
    transition: transform 0.1s;
  }

  .slider::-moz-range-thumb:hover {
    transform: scale(1.15);
  }

  .slider-value {
    min-width: 55px;
    text-align: right;
    font-variant-numeric: tabular-nums;
    font-family: monospace;
    font-size: 1rem;
    font-weight: bold;
    color: #ff6b9d;
    background: rgba(0, 0, 0, 0.3);
    padding: 6px 10px;
    border-radius: 6px;
    border: 1px solid rgba(255, 51, 102, 0.2);
  }
</style>

<div class="main-container">
  <div class="canvas-container">
    <canvas id="heartCanvas"></canvas>
  </div>

  <div class="controls-panel">
    <div class="controls-title">✨ 3D 회전 제어 (Rotation Controls)</div>
    <div class="slider-group">
      <span class="slider-label">X 축</span>
      <input type="range" id="rotationXSlider" class="slider" min="0" max="360" value="0">
      <span class="slider-value" id="rotationXValue">0°</span>
    </div>
    <div class="slider-group">
      <span class="slider-label">Y 축</span>
      <input type="range" id="rotationYSlider" class="slider" min="0" max="360" value="0">
      <span class="slider-value" id="rotationYValue">0°</span>
    </div>
    <div class="slider-group">
      <span class="slider-label">Z 축</span>
      <input type="range" id="rotationZSlider" class="slider" min="0" max="360" value="0">
      <span class="slider-value" id="rotationZValue">0°</span>
    </div>
  </div>
</div>

<script>
  // ============================================
  // 설정 상수
  // ============================================
  const Config = {
    // 파티클 생성 설정
    PARTICLE_STEP: 0.015,
    PARTICLE_RANGE: 1.5,
    SURFACE_EPSILON: 0.03,
    EDGE_SKIP_PROBABILITY: 0.2,

    // 회전 설정
    ROTATION_SMOOTHING: 0.15,
    SLIDER_OFFSET: { x: 90, y: 180, z: 0 },

    // 렌더링 설정
    SCALE_DIVISOR: 7,
    PERSPECTIVE: 400,
    MOUSE_INFLUENCE_RADIUS: 80,  // 마우스 밀어내는 반경(원)을 아주 작게
    MOUSE_REPULSION_FORCE: 30,   // 효과 또한 살짝만 일어나도록 약하게 조정

    // 색상 설정 (매혹적인 진홍색/다크레드 음영을 위해 조정)
    COLOR: {
      BASE_RED: { min: 200, max: 255 },
      BASE_GREEN: { min: 0, max: 15 },
      BASE_BLUE: { min: 10, max: 40 },
      VARIATION_RANGE: 10
    },

    // 밝기 설정 (앞/뒤 입체감을 극대화하기 위해 명암 대비를 아주 크게 설정)
    BRIGHTNESS: {
      DEPTH_MIN: 0.1,    // 뒤에 있는 점들은 아예 어둡게 (그림자 구실)
      DEPTH_RANGE: 0.7,  // 앞에 튀어나온 점들은 확실히 밝게
      LIGHT_INTENSITY: 1.0
    },

    // 파티클 속성 변동 범위
    PARTICLE_VARIATION: {
      SIZE: { min: 0.4, max: 1.1 },
      OPACITY: { min: 0.5, max: 1.0 },
      COLOR: { min: -5, max: 5 }
    },

    // 전략 선택 (OCP: 확장 가능한 전략 패턴)
    STRATEGIES: {
      lighting: 'default',
      color: 'default',
      mouseInteraction: 'default'
    }
  };

  // ============================================
  // 상태 관리
  // ============================================
  const State = {
    canvas: null,
    ctx: null,
    width: 0,
    height: 0,
    mouse: { x: -9999, y: -9999 },
    mouseMoved: false,
    rotation: { x: 0, y: 0, z: 0 },
    targetRotation: { x: 0, y: 0, z: 0 },
    particles: [],
    sliders: {
      x: null,
      y: null,
      z: null,
      xValue: null,
      yValue: null,
      zValue: null
    }
  };

  // ============================================
  // 조명 설정
  // ============================================
  const Lighting = {
    direction: { x: 0.5, y: -0.5, z: 1 },
    normalized: null,

    init() {
      const length = Math.sqrt(
        this.direction.x ** 2 +
        this.direction.y ** 2 +
        this.direction.z ** 2
      );
      this.normalized = {
        x: this.direction.x / length,
        y: this.direction.y / length,
        z: this.direction.z / length
      };
    }
  };

  // ============================================
  // 수학 함수들
  // ============================================
  const MathUtils = {
    heartFunc3D(x, y, z) {
      const term1 = Math.pow(x * x + (9 * y * y) / 4 + z * z - 1, 3);
      const term2 = x * x * z * z * z;
      const term3 = (9 * y * y * z * z * z) / 200;
      return term1 - term2 - term3;
    },

    calculateNormal(x, y, z) {
      const h = 0.01;
      const dx = (this.heartFunc3D(x + h, y, z) - this.heartFunc3D(x - h, y, z)) / (2 * h);
      const dy = (this.heartFunc3D(x, y + h, z) - this.heartFunc3D(x, y - h, z)) / (2 * h);
      const dz = (this.heartFunc3D(x, y, z + h) - this.heartFunc3D(x, y, z - h)) / (2 * h);

      const length = Math.sqrt(dx * dx + dy * dy + dz * dz);
      if (length === 0) return { x: 0, y: 0, z: 1 };
      return { x: dx / length, y: dy / length, z: dz / length };
    },

    rotate3D(x, y, z, rotX, rotY, rotZ) {
      let x1 = x * Math.cos(rotY) - z * Math.sin(rotY);
      let z1 = x * Math.sin(rotY) + z * Math.cos(rotY);
      let y1 = y;

      let y2 = y1 * Math.cos(rotX) - z1 * Math.sin(rotX);
      let z2 = y1 * Math.sin(rotX) + z1 * Math.cos(rotX);

      let x3 = x1 * Math.cos(rotZ) - y2 * Math.sin(rotZ);
      let y3 = x1 * Math.sin(rotZ) + y2 * Math.cos(rotZ);

      return { x: x3, y: y3, z: z2 };
    },

    degToRad(degrees) {
      return (degrees * Math.PI) / 180;
    }
  };

  // ============================================
  // 파티클 관리
  // ============================================
  const ParticleSystem = {
    init() {
      State.particles = [];
      const { PARTICLE_STEP, PARTICLE_RANGE, SURFACE_EPSILON, EDGE_SKIP_PROBABILITY } = Config;

      for (let x = -PARTICLE_RANGE; x <= PARTICLE_RANGE; x += PARTICLE_STEP) {
        for (let y = -PARTICLE_RANGE; y <= PARTICLE_RANGE; y += PARTICLE_STEP) {
          for (let z = -PARTICLE_RANGE; z <= PARTICLE_RANGE; z += PARTICLE_STEP) {
            if (MathUtils.heartFunc3D(x, y, z) <= 0) {
              const isNearSurface = this.checkNearSurface(x, y, z, SURFACE_EPSILON);

              if (isNearSurface) {
                const isEdge = this.checkIsEdge(x, y, z, SURFACE_EPSILON);

                if (isEdge && Math.random() > EDGE_SKIP_PROBABILITY) {
                  continue;
                }

                const normal = MathUtils.calculateNormal(x, y, z);
                State.particles.push({
                  origX: x,
                  origY: y,
                  origZ: z,
                  normalX: normal.x,
                  normalY: normal.y,
                  normalZ: normal.z,
                  sizeVariation: Config.PARTICLE_VARIATION.SIZE.min +
                    Math.random() * (Config.PARTICLE_VARIATION.SIZE.max - Config.PARTICLE_VARIATION.SIZE.min),
                  opacityVariation: Config.PARTICLE_VARIATION.OPACITY.min +
                    Math.random() * (Config.PARTICLE_VARIATION.OPACITY.max - Config.PARTICLE_VARIATION.OPACITY.min),
                  colorVariation: Config.PARTICLE_VARIATION.COLOR.min +
                    Math.random() * (Config.PARTICLE_VARIATION.COLOR.max - Config.PARTICLE_VARIATION.COLOR.min)
                });
              }
            }
          }
        }
      }
    },

    checkNearSurface(x, y, z, epsilon) {
      return MathUtils.heartFunc3D(x + epsilon, y, z) > 0 ||
        MathUtils.heartFunc3D(x - epsilon, y, z) > 0 ||
        MathUtils.heartFunc3D(x, y + epsilon, z) > 0 ||
        MathUtils.heartFunc3D(x, y - epsilon, z) > 0 ||
        MathUtils.heartFunc3D(x, y, z + epsilon) > 0 ||
        MathUtils.heartFunc3D(x, y, z - epsilon) > 0;
    },

    checkIsEdge(x, y, z, epsilon) {
      return this.checkNearSurface(x, y, z, epsilon * 2);
    }
  };

  const RotationController = {
    update() {
      const smoothing = Config.ROTATION_SMOOTHING;
      State.rotation.x += (State.targetRotation.x - State.rotation.x) * smoothing;
      State.rotation.y += (State.targetRotation.y - State.rotation.y) * smoothing;
      State.rotation.z += (State.targetRotation.z - State.rotation.z) * smoothing;
    }
  };

  const ParticleProcessor = {
    process() {
      return State.particles.map(p => {
        const rotated = MathUtils.rotate3D(
          p.origX, p.origY, p.origZ,
          State.rotation.x, State.rotation.y, State.rotation.z
        );
        const rotatedNormal = MathUtils.rotate3D(
          p.normalX, p.normalY, p.normalZ,
          State.rotation.x, State.rotation.y, State.rotation.z
        );
        return {
          ...p,
          rotated,
          rotatedNormal,
          screenZ: rotated.z
        };
      }).sort((a, b) => b.screenZ - a.screenZ);
    }
  };

  const MouseInteractionStrategyDefault = {
    name: 'default',
    calculate(screenX, screenY) {
      if (!State.mouseMoved) {
        return { x: 0, y: 0 };
      }

      const { MOUSE_INFLUENCE_RADIUS, MOUSE_REPULSION_FORCE } = Config;
      const dx = State.mouse.x - screenX;
      const dy = State.mouse.y - screenY;
      const distSq = dx * dx + dy * dy;
      const maxDistSq = MOUSE_INFLUENCE_RADIUS * MOUSE_INFLUENCE_RADIUS;

      if (distSq >= maxDistSq || distSq === 0) {
        return { x: 0, y: 0 };
      }

      const dist = Math.sqrt(distSq);
      const force = Math.max(0, MOUSE_INFLUENCE_RADIUS - dist) / MOUSE_INFLUENCE_RADIUS;
      return {
        x: (dx / dist) * force * -MOUSE_REPULSION_FORCE,
        y: (dy / dist) * force * -MOUSE_REPULSION_FORCE
      };
    }
  };

  const MouseInteractionStrategyRegistry = {
    strategies: new Map(),

    register(strategy) {
      this.strategies.set(strategy.name, strategy);
    },

    get(name) {
      return this.strategies.get(name) || this.strategies.get('default');
    }
  };

  MouseInteractionStrategyRegistry.register(MouseInteractionStrategyDefault);

  const MouseInteraction = {
    calculateRepulsion(screenX, screenY) {
      const strategyName = Config.STRATEGIES.mouseInteraction;
      const strategy = MouseInteractionStrategyRegistry.get(strategyName);
      return strategy.calculate(screenX, screenY);
    }
  };

  const LightingStrategyDefault = {
    name: 'default',
    calculate(rotatedNormal) {
      const dotProduct =
        rotatedNormal.x * Lighting.normalized.x +
        rotatedNormal.y * Lighting.normalized.y +
        rotatedNormal.z * Lighting.normalized.z;
      return Math.max(0, Math.min(1, (dotProduct + 1) / 2));
    }
  };

  const LightingStrategyRegistry = {
    strategies: new Map(),

    register(strategy) {
      this.strategies.set(strategy.name, strategy);
    },

    get(name) {
      return this.strategies.get(name) || this.strategies.get('default');
    }
  };

  LightingStrategyRegistry.register(LightingStrategyDefault);

  const LightingCalculator = {
    calculateIntensity(rotatedNormal) {
      const strategyName = Config.STRATEGIES.lighting;
      const strategy = LightingStrategyRegistry.get(strategyName);
      return strategy.calculate(rotatedNormal);
    }
  };

  const ColorStrategyDefault = {
    name: 'default',
    calculate(brightness, colorVariation) {
      const { BASE_RED, BASE_GREEN, BASE_BLUE } = Config.COLOR;
      const redRange = BASE_RED.max - BASE_RED.min;
      const greenRange = BASE_GREEN.max - BASE_GREEN.min;
      const blueRange = BASE_BLUE.max - BASE_BLUE.min;

      const baseRed = BASE_RED.min + brightness * redRange;
      const baseGreen = BASE_GREEN.min + brightness * greenRange;
      const baseBlue = BASE_BLUE.min + brightness * blueRange;

      return {
        red: Math.floor(Math.max(0, Math.min(255, baseRed + colorVariation))),
        green: Math.floor(Math.max(0, Math.min(255, baseGreen + colorVariation * 0.5))),
        blue: Math.floor(Math.max(0, Math.min(255, baseBlue + colorVariation * 0.5)))
      };
    }
  };

  const ColorStrategyRegistry = {
    strategies: new Map(),

    register(strategy) {
      this.strategies.set(strategy.name, strategy);
    },

    get(name) {
      return this.strategies.get(name) || this.strategies.get('default');
    }
  };

  ColorStrategyRegistry.register(ColorStrategyDefault);

  const ColorCalculator = {
    calculate(brightness, colorVariation, normalizedZ = 0) {
      const strategyName = Config.STRATEGIES.color;
      const strategy = ColorStrategyRegistry.get(strategyName);
      return strategy.calculate(brightness, colorVariation, normalizedZ);
    }
  };

  const Renderer = {
    render() {
      State.ctx.clearRect(0, 0, State.width, State.height);

      RotationController.update();

      const sortedParticles = ParticleProcessor.process();

      const scale = Math.min(State.width, State.height) / Config.SCALE_DIVISOR;
      const centerX = State.width / 2;
      const centerY = State.height / 2;
      const perspective = Config.PERSPECTIVE;

      for (const p of sortedParticles) {
        const scale3D = perspective / (perspective + p.rotated.z);
        const screenX = centerX + p.rotated.x * scale * scale3D;
        const screenY = centerY - p.rotated.y * scale * scale3D;

        const repulsion = MouseInteraction.calculateRepulsion(screenX, screenY);
        const finalX = screenX + repulsion.x;
        const finalY = screenY + repulsion.y;

        const lightIntensity = LightingCalculator.calculateIntensity(p.rotatedNormal);

        const normalizedZ = (p.rotated.z + Config.PARTICLE_RANGE) / (Config.PARTICLE_RANGE * 2);
        const depthBrightness = Config.BRIGHTNESS.DEPTH_MIN + normalizedZ * Config.BRIGHTNESS.DEPTH_RANGE;
        const brightness = depthBrightness + lightIntensity * Config.BRIGHTNESS.LIGHT_INTENSITY;

        const color = ColorCalculator.calculate(brightness, p.colorVariation, normalizedZ);

        const baseSize = (0.6 + normalizedZ * 0.3) * scale3D;
        const size = baseSize * p.sizeVariation;
        const opacity = (0.85 + brightness * 0.15) * p.opacityVariation;

        State.ctx.beginPath();
        State.ctx.fillStyle = `rgba(${color.red}, ${color.green}, ${color.blue}, ${Math.max(0.3, Math.min(1, opacity))})`;
        State.ctx.arc(finalX, finalY, size, 0, Math.PI * 2);
        State.ctx.fill();
      }

      requestAnimationFrame(() => this.render());
    }
  };

  const EventHandlers = {
    initSliders() {
      const { x, y, z, xValue, yValue, zValue } = State.sliders;
      const { SLIDER_OFFSET } = Config;

      const updateRotation = (slider, valueElement, axis, offset) => {
        const degrees = parseInt(slider.value);
        State.targetRotation[axis] = MathUtils.degToRad(degrees + offset);
        valueElement.textContent = degrees + "°";
      };

      x.addEventListener("input", (e) => updateRotation(x, xValue, "x", SLIDER_OFFSET.x));
      y.addEventListener("input", (e) => updateRotation(y, yValue, "y", SLIDER_OFFSET.y));
      z.addEventListener("input", (e) => updateRotation(z, zValue, "z", SLIDER_OFFSET.z));

      const initialX = parseInt(x.value);
      const initialY = parseInt(y.value);
      const initialZ = parseInt(z.value);

      State.rotation.x = State.targetRotation.x = MathUtils.degToRad(initialX + SLIDER_OFFSET.x);
      State.rotation.y = State.targetRotation.y = MathUtils.degToRad(initialY + SLIDER_OFFSET.y);
      State.rotation.z = State.targetRotation.z = MathUtils.degToRad(initialZ + SLIDER_OFFSET.z);
    },

    initMouse() {
      window.addEventListener("mousemove", (e) => {
        const container = State.canvas.parentElement;
        const rect = container.getBoundingClientRect();
        State.mouse.x = e.clientX - rect.left;
        State.mouse.y = e.clientY - rect.top;
        State.mouseMoved = true;
      });
    },

    initResize() {
      window.addEventListener("resize", () => {
        const container = State.canvas.parentElement;
        State.width = State.canvas.width = container.clientWidth;
        State.height = State.canvas.height = container.clientHeight;
        ParticleSystem.init();
      });
    }
  };

  function init() {
    State.canvas = document.getElementById("heartCanvas");
    State.ctx = State.canvas.getContext("2d");

    const container = State.canvas.parentElement;
    State.width = State.canvas.width = container.clientWidth;
    State.height = State.canvas.height = container.clientHeight;

    State.mouse = { x: -9999, y: -9999 };
    State.mouseMoved = false;

    State.sliders.x = document.getElementById("rotationXSlider");
    State.sliders.y = document.getElementById("rotationYSlider");
    State.sliders.z = document.getElementById("rotationZSlider");
    State.sliders.xValue = document.getElementById("rotationXValue");
    State.sliders.yValue = document.getElementById("rotationYValue");
    State.sliders.zValue = document.getElementById("rotationZValue");

    Lighting.init();

    EventHandlers.initSliders();
    EventHandlers.initMouse();
    EventHandlers.initResize();

    ParticleSystem.init();

    Renderer.render();
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
</script>