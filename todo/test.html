<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>하트?</title>
<style>
  body {
    margin: 0;
    padding: 0;
    background: radial-gradient(circle at center, #1a001a, #000);
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
  }
  .main-container {
    position: relative;
    width: 90%;
    max-width: 1000px;
    display: flex;
    flex-direction: column;
    gap: 20px;
    padding: 20px;
    background: rgba(0, 0, 0, 0.4);
    border-radius: 15px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
  }
  .canvas-container {
    position: relative;
    width: 100%;
    height: 70vh;
    min-height: 500px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 10px;
    overflow: hidden;
  }
  .canvas-container::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 300px;
    height: 270px;
    background: radial-gradient(circle at 50% 50%, rgba(255, 20, 147, 0.3), transparent 70%);
    border-radius: 50%;
    z-index: 0;
    animation: pulse 3s ease-in-out infinite;
  }
  .canvas-container::after {
    content: '♥';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 200px;
    color: rgba(255, 20, 147, 0.2);
    text-shadow: 
      0 0 20px rgba(255, 20, 147, 0.5),
      0 0 40px rgba(255, 20, 147, 0.4),
      0 0 60px rgba(255, 20, 147, 0.3),
      0 0 80px rgba(255, 20, 147, 0.2);
    z-index: 0;
    animation: glow 2s ease-in-out infinite alternate;
    pointer-events: none;
  }
  @keyframes pulse {
    0%, 100% {
      opacity: 0.3;
      transform: translate(-50%, -50%) scale(1);
    }
    50% {
      opacity: 0.5;
      transform: translate(-50%, -50%) scale(1.1);
    }
  }
  @keyframes glow {
    0% {
      opacity: 0.2;
      text-shadow: 
        0 0 20px rgba(255, 20, 147, 0.5),
        0 0 40px rgba(255, 20, 147, 0.4),
        0 0 60px rgba(255, 20, 147, 0.3),
        0 0 80px rgba(255, 20, 147, 0.2);
    }
    100% {
      opacity: 0.4;
      text-shadow: 
        0 0 30px rgba(255, 20, 147, 0.7),
        0 0 50px rgba(255, 20, 147, 0.6),
        0 0 70px rgba(255, 20, 147, 0.5),
        0 0 100px rgba(255, 20, 147, 0.4);
    }
  }
  canvas {
    display: block;
    width: 100%;
    height: 100%;
    position: relative;
    z-index: 1;
  }
  .slider-container {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    color: white;
    font-family: Arial, sans-serif;
    font-size: 14px;
    background: rgba(0, 0, 0, 0.5);
    padding: 15px 20px;
    border-radius: 8px;
    flex-direction: row;
  }
  .slider-container.vertical {
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
    flex-direction: column;
  }
  .slider-group {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .slider {
    width: 150px;
    height: 6px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 3px;
    outline: none;
    cursor: pointer;
  }
  .slider-label {
    min-width: 60px;
    text-align: center;
    font-size: 12px;
  }
  .slider-value {
    min-width: 50px;
    text-align: center;
    font-size: 12px;
    color: #ff6b9d;
  }
</style>
</head>
<body>
<div class="main-container">
  <div class="canvas-container">
    <canvas id="heartCanvas"></canvas>
  </div>
  <!-- 회전 슬라이더 컨테이너 -->
  <div class="slider-container">
    <div class="slider-group">
      <span class="slider-label">X축</span>
      <input type="range" id="rotationXSlider" class="slider" min="0" max="360" value="0">
      <span class="slider-value" id="rotationXValue">0°</span>
    </div>
    <div class="slider-group">
      <span class="slider-label">Y축</span>
      <input type="range" id="rotationYSlider" class="slider" min="0" max="360" value="0">
      <span class="slider-value" id="rotationYValue">0°</span>
    </div>
    <div class="slider-group">
      <span class="slider-label">Z축</span>
      <input type="range" id="rotationZSlider" class="slider" min="0" max="360" value="0">
      <span class="slider-value" id="rotationZValue">0°</span>
    </div>
  </div>
</div>
<script>
// ============================================
// 설정 상수
// ============================================
const Config = {
  // 파티클 생성 설정
  PARTICLE_STEP: 0.035,
  PARTICLE_RANGE: 1.5,
  SURFACE_EPSILON: 0.03,
  EDGE_SKIP_PROBABILITY: 0.6,
  
  // 회전 설정
  ROTATION_SMOOTHING: 0.2,
  SLIDER_OFFSET: { x: 90, y: 180, z: 0 },
  
  // 렌더링 설정
  SCALE_DIVISOR: 7,
  PERSPECTIVE: 400,
  MOUSE_INFLUENCE_RADIUS: 500,
  MOUSE_REPULSION_FORCE: 15,
  
  // 색상 설정
  COLOR: {
    BASE_RED: { min: 150, max: 255 },
    BASE_GREEN: { min: 20, max: 70 },
    BASE_BLUE: { min: 20, max: 70 },
    VARIATION_RANGE: 15
  },
  
  // 밝기 설정
  BRIGHTNESS: {
    DEPTH_MIN: 0.4,
    DEPTH_RANGE: 0.4,
    LIGHT_INTENSITY: 0.6
  },
  
  // 파티클 속성 변동 범위
  PARTICLE_VARIATION: {
    SIZE: { min: 0.6, max: 1.4 },
    OPACITY: { min: 0.7, max: 1.0 },
    COLOR: { min: -15, max: 15 }
  },
  
  // 전략 선택 (OCP: 확장 가능한 전략 패턴)
  STRATEGIES: {
    lighting: 'default',      // 'default', 'ambient', 'phong' 등으로 확장 가능
    color: 'default',          // 'default', 'gradient', 'rainbow' 등으로 확장 가능
    mouseInteraction: 'default' // 'default', 'attraction', 'none' 등으로 확장 가능
  }
};

// ============================================
// 상태 관리
// ============================================
const State = {
  canvas: null,
  ctx: null,
  width: 0,
  height: 0,
  mouse: { x: -9999, y: -9999 }, // 초기값을 화면 밖으로 설정 (밀림 효과 없음)
  mouseMoved: false, // 마우스가 실제로 움직였는지 추적
  rotation: { x: 0, y: 0, z: 0 },
  targetRotation: { x: 0, y: 0, z: 0 },
  particles: [],
  sliders: {
    x: null,
    y: null,
    z: null,
    xValue: null,
    yValue: null,
    zValue: null
  }
};

// ============================================
// 조명 설정
// ============================================
const Lighting = {
  direction: { x: 0.5, y: -0.5, z: 1 },
  normalized: null,
  
  init() {
    const length = Math.sqrt(
      this.direction.x ** 2 +
      this.direction.y ** 2 +
      this.direction.z ** 2
    );
    this.normalized = {
      x: this.direction.x / length,
      y: this.direction.y / length,
      z: this.direction.z / length
    };
  }
};

// ============================================
// 수학 함수들
// ============================================
const MathUtils = {
  // 3D 하트 방정식
  heartFunc3D(x, y, z) {
    const term1 = Math.pow(x * x + (9 * y * y) / 4 + z * z - 1, 3);
    const term2 = x * x * z * z * z;
    const term3 = (9 * y * y * z * z * z) / 200;
    return term1 - term2 - term3;
  },
  
  // 법선 벡터 계산
  calculateNormal(x, y, z) {
    const h = 0.01;
    const dx = (this.heartFunc3D(x + h, y, z) - this.heartFunc3D(x - h, y, z)) / (2 * h);
    const dy = (this.heartFunc3D(x, y + h, z) - this.heartFunc3D(x, y - h, z)) / (2 * h);
    const dz = (this.heartFunc3D(x, y, z + h) - this.heartFunc3D(x, y, z - h)) / (2 * h);
    
    const length = Math.sqrt(dx * dx + dy * dy + dz * dz);
    if (length === 0) return { x: 0, y: 0, z: 1 };
    return { x: dx / length, y: dy / length, z: dz / length };
  },
  
  // 3D 회전 변환
  rotate3D(x, y, z, rotX, rotY, rotZ) {
    // Y축 회전
    let x1 = x * Math.cos(rotY) - z * Math.sin(rotY);
    let z1 = x * Math.sin(rotY) + z * Math.cos(rotY);
    let y1 = y;
    
    // X축 회전
    let y2 = y1 * Math.cos(rotX) - z1 * Math.sin(rotX);
    let z2 = y1 * Math.sin(rotX) + z1 * Math.cos(rotX);
    
    // Z축 회전
    let x3 = x1 * Math.cos(rotZ) - y2 * Math.sin(rotZ);
    let y3 = x1 * Math.sin(rotZ) + y2 * Math.cos(rotZ);
    
    return { x: x3, y: y3, z: z2 };
  },
  
  // 각도를 라디안으로 변환
  degToRad(degrees) {
    return (degrees * Math.PI) / 180;
  }
};

// ============================================
// 파티클 관리
// ============================================
const ParticleSystem = {
  init() {
    State.particles = [];
    const { PARTICLE_STEP, PARTICLE_RANGE, SURFACE_EPSILON, EDGE_SKIP_PROBABILITY } = Config;
    
    for (let x = -PARTICLE_RANGE; x <= PARTICLE_RANGE; x += PARTICLE_STEP) {
      for (let y = -PARTICLE_RANGE; y <= PARTICLE_RANGE; y += PARTICLE_STEP) {
        for (let z = -PARTICLE_RANGE; z <= PARTICLE_RANGE; z += PARTICLE_STEP) {
          if (MathUtils.heartFunc3D(x, y, z) <= 0) {
            const isNearSurface = this.checkNearSurface(x, y, z, SURFACE_EPSILON);
            
            if (isNearSurface) {
              const isEdge = this.checkIsEdge(x, y, z, SURFACE_EPSILON);
              
              if (isEdge && Math.random() > EDGE_SKIP_PROBABILITY) {
                continue;
              }
              
              const normal = MathUtils.calculateNormal(x, y, z);
              State.particles.push({
                origX: x,
                origY: y,
                origZ: z,
                normalX: normal.x,
                normalY: normal.y,
                normalZ: normal.z,
                sizeVariation: Config.PARTICLE_VARIATION.SIZE.min + 
                              Math.random() * (Config.PARTICLE_VARIATION.SIZE.max - Config.PARTICLE_VARIATION.SIZE.min),
                opacityVariation: Config.PARTICLE_VARIATION.OPACITY.min + 
                                 Math.random() * (Config.PARTICLE_VARIATION.OPACITY.max - Config.PARTICLE_VARIATION.OPACITY.min),
                colorVariation: Config.PARTICLE_VARIATION.COLOR.min + 
                               Math.random() * (Config.PARTICLE_VARIATION.COLOR.max - Config.PARTICLE_VARIATION.COLOR.min)
              });
            }
          }
        }
      }
    }
  },
  
  checkNearSurface(x, y, z, epsilon) {
    return MathUtils.heartFunc3D(x + epsilon, y, z) > 0 ||
           MathUtils.heartFunc3D(x - epsilon, y, z) > 0 ||
           MathUtils.heartFunc3D(x, y + epsilon, z) > 0 ||
           MathUtils.heartFunc3D(x, y - epsilon, z) > 0 ||
           MathUtils.heartFunc3D(x, y, z + epsilon) > 0 ||
           MathUtils.heartFunc3D(x, y, z - epsilon) > 0;
  },
  
  checkIsEdge(x, y, z, epsilon) {
    return this.checkNearSurface(x, y, z, epsilon * 2);
  }
};

// ============================================
// 회전 제어 (SRP: 회전 업데이트만 담당)
// ============================================
const RotationController = {
  update() {
    const smoothing = Config.ROTATION_SMOOTHING;
    State.rotation.x += (State.targetRotation.x - State.rotation.x) * smoothing;
    State.rotation.y += (State.targetRotation.y - State.rotation.y) * smoothing;
    State.rotation.z += (State.targetRotation.z - State.rotation.z) * smoothing;
  }
};

// ============================================
// 파티클 처리 (SRP: 파티클 변환 및 정렬만 담당)
// ============================================
const ParticleProcessor = {
  process() {
    return State.particles.map(p => {
      const rotated = MathUtils.rotate3D(
        p.origX, p.origY, p.origZ,
        State.rotation.x, State.rotation.y, State.rotation.z
      );
      const rotatedNormal = MathUtils.rotate3D(
        p.normalX, p.normalY, p.normalZ,
        State.rotation.x, State.rotation.y, State.rotation.z
      );
      return {
        ...p,
        rotated,
        rotatedNormal,
        screenZ: rotated.z
      };
    }).sort((a, b) => b.screenZ - a.screenZ);
  }
};

// ============================================
// 마우스 상호작용 전략 인터페이스 (OCP: 확장 가능)
// ============================================
// 각 전략은 독립적인 모듈로 분리 (SRP: 단일 책임)
const MouseInteractionStrategyDefault = {
  name: 'default',
  calculate(screenX, screenY) {
    // 마우스가 실제로 움직이지 않았으면 밀림 효과 없음
    if (!State.mouseMoved) {
      return { x: 0, y: 0 };
    }
    
    const { MOUSE_INFLUENCE_RADIUS, MOUSE_REPULSION_FORCE } = Config;
    const dx = State.mouse.x - screenX;
    const dy = State.mouse.y - screenY;
    const distSq = dx * dx + dy * dy;
    const maxDistSq = MOUSE_INFLUENCE_RADIUS * MOUSE_INFLUENCE_RADIUS;
    
    if (distSq >= maxDistSq || distSq === 0) {
      return { x: 0, y: 0 };
    }
    
    const dist = Math.sqrt(distSq);
    const force = Math.max(0, MOUSE_INFLUENCE_RADIUS - dist) / MOUSE_INFLUENCE_RADIUS;
    return {
      x: (dx / dist) * force * -MOUSE_REPULSION_FORCE,
      y: (dy / dist) * force * -MOUSE_REPULSION_FORCE
    };
  }
};

const MouseInteractionStrategyAttraction = {
  name: 'attraction',
  calculate(screenX, screenY) {
    // 마우스가 실제로 움직이지 않았으면 밀림 효과 없음
    if (!State.mouseMoved) {
      return { x: 0, y: 0 };
    }
    
    const { MOUSE_INFLUENCE_RADIUS } = Config;
    const dx = State.mouse.x - screenX;
    const dy = State.mouse.y - screenY;
    const distSq = dx * dx + dy * dy;
    const maxDistSq = MOUSE_INFLUENCE_RADIUS * MOUSE_INFLUENCE_RADIUS;
    
    if (distSq >= maxDistSq || distSq === 0) {
      return { x: 0, y: 0 };
    }
    
    const dist = Math.sqrt(distSq);
    const force = Math.max(0, MOUSE_INFLUENCE_RADIUS - dist) / MOUSE_INFLUENCE_RADIUS;
    return {
      x: (dx / dist) * force * 10,
      y: (dy / dist) * force * 10
    };
  }
};

const MouseInteractionStrategyNone = {
  name: 'none',
  calculate() {
    return { x: 0, y: 0 };
  }
};

// ============================================
// 전략 레지스트리 (OCP: 전략 등록 시스템)
// ============================================
const MouseInteractionStrategyRegistry = {
  strategies: new Map(),
  
  register(strategy) {
    this.strategies.set(strategy.name, strategy);
  },
  
  get(name) {
    return this.strategies.get(name) || this.strategies.get('default');
  }
};

// 기본 전략 등록
MouseInteractionStrategyRegistry.register(MouseInteractionStrategyDefault);
MouseInteractionStrategyRegistry.register(MouseInteractionStrategyAttraction);
MouseInteractionStrategyRegistry.register(MouseInteractionStrategyNone);

// ============================================
// 마우스 상호작용 (SRP: 전략 사용만 담당)
// ============================================
const MouseInteraction = {
  calculateRepulsion(screenX, screenY) {
    const strategyName = Config.STRATEGIES.mouseInteraction;
    const strategy = MouseInteractionStrategyRegistry.get(strategyName);
    return strategy.calculate(screenX, screenY);
  }
};

// ============================================
// 조명 계산 전략 인터페이스 (OCP: 확장 가능)
// ============================================
// 각 전략은 독립적인 모듈로 분리 (SRP: 단일 책임)
const LightingStrategyDefault = {
  name: 'default',
  calculate(rotatedNormal) {
    const dotProduct = 
      rotatedNormal.x * Lighting.normalized.x +
      rotatedNormal.y * Lighting.normalized.y +
      rotatedNormal.z * Lighting.normalized.z;
    return Math.max(0, Math.min(1, (dotProduct + 1) / 2));
  }
};

const LightingStrategyAmbient = {
  name: 'ambient',
  calculate(rotatedNormal) {
    const dotProduct = 
      rotatedNormal.x * Lighting.normalized.x +
      rotatedNormal.y * Lighting.normalized.y +
      rotatedNormal.z * Lighting.normalized.z;
    return Math.max(0.3, Math.min(1, (dotProduct + 1) / 2 + 0.2));
  }
};

const LightingStrategyUniform = {
  name: 'uniform',
  calculate() {
    return 0.8;
  }
};

// ============================================
// 전략 레지스트리 (OCP: 전략 등록 시스템)
// ============================================
const LightingStrategyRegistry = {
  strategies: new Map(),
  
  register(strategy) {
    this.strategies.set(strategy.name, strategy);
  },
  
  get(name) {
    return this.strategies.get(name) || this.strategies.get('default');
  }
};

// 기본 전략 등록
LightingStrategyRegistry.register(LightingStrategyDefault);
LightingStrategyRegistry.register(LightingStrategyAmbient);
LightingStrategyRegistry.register(LightingStrategyUniform);

// ============================================
// 조명 계산 (SRP: 전략 사용만 담당)
// ============================================
const LightingCalculator = {
  calculateIntensity(rotatedNormal) {
    const strategyName = Config.STRATEGIES.lighting;
    const strategy = LightingStrategyRegistry.get(strategyName);
    return strategy.calculate(rotatedNormal);
  }
};

// ============================================
// 색상 계산 전략 인터페이스 (OCP: 확장 가능)
// ============================================
// 각 전략은 독립적인 모듈로 분리 (SRP: 단일 책임)
const ColorStrategyDefault = {
  name: 'default',
  calculate(brightness, colorVariation) {
    const { BASE_RED, BASE_GREEN, BASE_BLUE } = Config.COLOR;
    const redRange = BASE_RED.max - BASE_RED.min;
    const greenRange = BASE_GREEN.max - BASE_GREEN.min;
    const blueRange = BASE_BLUE.max - BASE_BLUE.min;
    
    const baseRed = BASE_RED.min + brightness * redRange;
    const baseGreen = BASE_GREEN.min + brightness * greenRange;
    const baseBlue = BASE_BLUE.min + brightness * blueRange;
    
    return {
      red: Math.floor(Math.max(0, Math.min(255, baseRed + colorVariation))),
      green: Math.floor(Math.max(0, Math.min(255, baseGreen + colorVariation * 0.5))),
      blue: Math.floor(Math.max(0, Math.min(255, baseBlue + colorVariation * 0.5)))
    };
  }
};

const ColorStrategyGradient = {
  name: 'gradient',
  calculate(brightness, colorVariation, normalizedZ) {
    const hue = normalizedZ * 360;
    const saturation = 0.7 + brightness * 0.3;
    const lightness = 0.4 + brightness * 0.3;
    
    const c = (1 - Math.abs(2 * lightness - 1)) * saturation;
    const x = c * (1 - Math.abs((hue / 60) % 2 - 1));
    const m = lightness - c / 2;
    
    let r, g, b;
    if (hue < 60) { r = c; g = x; b = 0; }
    else if (hue < 120) { r = x; g = c; b = 0; }
    else if (hue < 180) { r = 0; g = c; b = x; }
    else if (hue < 240) { r = 0; g = x; b = c; }
    else if (hue < 300) { r = x; g = 0; b = c; }
    else { r = c; g = 0; b = x; }
    
    return {
      red: Math.floor((r + m) * 255),
      green: Math.floor((g + m) * 255),
      blue: Math.floor((b + m) * 255)
    };
  }
};

const ColorStrategyRainbow = {
  name: 'rainbow',
  calculate(brightness, colorVariation, normalizedZ) {
    const hue = (normalizedZ * 360 + Date.now() * 0.01) % 360;
    const saturation = 0.8;
    const lightness = 0.5 + brightness * 0.2;
    
    const c = (1 - Math.abs(2 * lightness - 1)) * saturation;
    const x = c * (1 - Math.abs((hue / 60) % 2 - 1));
    const m = lightness - c / 2;
    
    let r, g, b;
    if (hue < 60) { r = c; g = x; b = 0; }
    else if (hue < 120) { r = x; g = c; b = 0; }
    else if (hue < 180) { r = 0; g = c; b = x; }
    else if (hue < 240) { r = 0; g = x; b = c; }
    else if (hue < 300) { r = x; g = 0; b = c; }
    else { r = c; g = 0; b = x; }
    
    return {
      red: Math.floor((r + m) * 255),
      green: Math.floor((g + m) * 255),
      blue: Math.floor((b + m) * 255)
    };
  }
};

// ============================================
// 전략 레지스트리 (OCP: 전략 등록 시스템)
// ============================================
const ColorStrategyRegistry = {
  strategies: new Map(),
  
  register(strategy) {
    this.strategies.set(strategy.name, strategy);
  },
  
  get(name) {
    return this.strategies.get(name) || this.strategies.get('default');
  }
};

// 기본 전략 등록
ColorStrategyRegistry.register(ColorStrategyDefault);
ColorStrategyRegistry.register(ColorStrategyGradient);
ColorStrategyRegistry.register(ColorStrategyRainbow);

// ============================================
// 색상 계산 (SRP: 전략 사용만 담당)
// ============================================
const ColorCalculator = {
  calculate(brightness, colorVariation, normalizedZ = 0) {
    const strategyName = Config.STRATEGIES.color;
    const strategy = ColorStrategyRegistry.get(strategyName);
    return strategy.calculate(brightness, colorVariation, normalizedZ);
  }
};

// ============================================
// 렌더링 (SRP: 화면에 그리기만 담당)
// ============================================
const Renderer = {
  render() {
    State.ctx.clearRect(0, 0, State.width, State.height);
    
    // 회전 업데이트
    RotationController.update();
    
    // 파티클 처리 및 정렬
    const sortedParticles = ParticleProcessor.process();
    
    // 렌더링 설정
    const scale = Math.min(State.width, State.height) / Config.SCALE_DIVISOR;
    const centerX = State.width / 2;
    const centerY = State.height / 2;
    const perspective = Config.PERSPECTIVE;
    
    // 각 파티클 렌더링
    for (const p of sortedParticles) {
      const scale3D = perspective / (perspective + p.rotated.z);
      const screenX = centerX + p.rotated.x * scale * scale3D;
      const screenY = centerY - p.rotated.y * scale * scale3D;
      
      // 마우스 반발력 계산
      const repulsion = MouseInteraction.calculateRepulsion(screenX, screenY);
      const finalX = screenX + repulsion.x;
      const finalY = screenY + repulsion.y;
      
      // 조명 강도 계산
      const lightIntensity = LightingCalculator.calculateIntensity(p.rotatedNormal);
      
      // 밝기 계산
      const normalizedZ = (p.rotated.z + Config.PARTICLE_RANGE) / (Config.PARTICLE_RANGE * 2);
      const depthBrightness = Config.BRIGHTNESS.DEPTH_MIN + normalizedZ * Config.BRIGHTNESS.DEPTH_RANGE;
      const brightness = depthBrightness + lightIntensity * Config.BRIGHTNESS.LIGHT_INTENSITY;
      
      // 색상 계산 (normalizedZ 전달하여 전략에서 사용 가능)
      const color = ColorCalculator.calculate(brightness, p.colorVariation, normalizedZ);
      
      // 크기 및 투명도 계산
      const baseSize = (0.6 + normalizedZ * 0.3) * scale3D;
      const size = baseSize * p.sizeVariation;
      const opacity = (0.85 + brightness * 0.15) * p.opacityVariation;
      
      // 그리기
      State.ctx.beginPath();
      State.ctx.fillStyle = `rgba(${color.red}, ${color.green}, ${color.blue}, ${Math.max(0.3, Math.min(1, opacity))})`;
      State.ctx.arc(finalX, finalY, size, 0, Math.PI * 2);
      State.ctx.fill();
    }
    
    requestAnimationFrame(() => this.render());
  }
};

// ============================================
// 이벤트 핸들러
// ============================================
const EventHandlers = {
  initSliders() {
    const { x, y, z, xValue, yValue, zValue } = State.sliders;
    const { SLIDER_OFFSET } = Config;
    
    const updateRotation = (slider, valueElement, axis, offset) => {
      const degrees = parseInt(slider.value);
      State.targetRotation[axis] = MathUtils.degToRad(degrees + offset);
      valueElement.textContent = degrees + "°";
    };
    
    x.addEventListener("input", (e) => updateRotation(x, xValue, "x", SLIDER_OFFSET.x));
    y.addEventListener("input", (e) => updateRotation(y, yValue, "y", SLIDER_OFFSET.y));
    z.addEventListener("input", (e) => updateRotation(z, zValue, "z", SLIDER_OFFSET.z));
    
    // 초기값 설정
    const initialX = parseInt(x.value);
    const initialY = parseInt(y.value);
    const initialZ = parseInt(z.value);
    
    State.rotation.x = State.targetRotation.x = MathUtils.degToRad(initialX + SLIDER_OFFSET.x);
    State.rotation.y = State.targetRotation.y = MathUtils.degToRad(initialY + SLIDER_OFFSET.y);
    State.rotation.z = State.targetRotation.z = MathUtils.degToRad(initialZ + SLIDER_OFFSET.z);
  },
  
  initMouse() {
    window.addEventListener("mousemove", (e) => {
      // 컨테이너 기준 상대 좌표로 변환
      const container = State.canvas.parentElement;
      const rect = container.getBoundingClientRect();
      State.mouse.x = e.clientX - rect.left;
      State.mouse.y = e.clientY - rect.top;
      State.mouseMoved = true; // 마우스가 실제로 움직였음을 표시
    });
  },
  
  initResize() {
    window.addEventListener("resize", () => {
      // 컨테이너 크기에 맞게 캔버스 크기 설정
      const container = State.canvas.parentElement;
      State.width = State.canvas.width = container.clientWidth;
      State.height = State.canvas.height = container.clientHeight;
      ParticleSystem.init();
    });
  }
};

// ============================================
// 초기화
// ============================================
function init() {
  // 캔버스 초기화
  State.canvas = document.getElementById("heartCanvas");
  State.ctx = State.canvas.getContext("2d");
  
  // 컨테이너 크기에 맞게 캔버스 크기 설정
  const container = State.canvas.parentElement;
  State.width = State.canvas.width = container.clientWidth;
  State.height = State.canvas.height = container.clientHeight;
  
  // 마우스 초기 위치를 화면 밖으로 설정 (밀림 효과 없음)
  State.mouse = { x: -9999, y: -9999 };
  State.mouseMoved = false;
  
  // 슬라이더 요소 가져오기
  State.sliders.x = document.getElementById("rotationXSlider");
  State.sliders.y = document.getElementById("rotationYSlider");
  State.sliders.z = document.getElementById("rotationZSlider");
  State.sliders.xValue = document.getElementById("rotationXValue");
  State.sliders.yValue = document.getElementById("rotationYValue");
  State.sliders.zValue = document.getElementById("rotationZValue");
  
  // 조명 초기화
  Lighting.init();
  
  // 이벤트 핸들러 초기화
  EventHandlers.initSliders();
  EventHandlers.initMouse();
  EventHandlers.initResize();
  
  // 파티클 초기화
  ParticleSystem.init();
  
  // 렌더링 시작
  Renderer.render();
}

// 프로그램 시작
init();
</script>
</body>
</html>